/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Deck-level tags for categorization
 */
export type Tags = string[];
/**
 * Tags for categorization
 */
export type Tags1 = string[];
/**
 * ULID identifier (26 characters, Crockford Base32)
 */
export type Id = string;
/**
 * Text direction
 */
export type Direction = "auto" | "ltr" | "rtl";
/**
 * Inline content
 */
export type Inline = string;
/**
 * Local file path (relative to the JSON/YAML file location)
 */
export type File = string;
/**
 * Web URL
 */
export type Url = string;
/**
 * Base64 encoded data
 */
export type Base64 = string;
/**
 * MIME type (e.g., image/png, application/json)
 */
export type Mime = string;
/**
 * Sort order for lists and sequences
 */
export type Sort = "unordered" | "ascending" | "descending";

/**
 * Schema for validating a deck of flashcards
 */
export interface OpenFlashcardStandardDeck {
    /**
     * URIs (e.g., https://...) or file paths (e.g., ./local/deck.json) of other flashcard sets to inherit from. Only `cards` are imported from the referenced decks; all metadata and settings from the source decks are ignored
     */
    extends?: string[];
    /**
     * Unique identifier for the deck
     */
    id: string;
    /**
     * Version of the Open Flashcard Standard
     */
    version?: string;
    /**
     * Name of the flashcard deck
     */
    name: string;
    /**
     * Optional description of the deck
     */
    description?: string;
    /**
     * ISO 8601 creation timestamp
     */
    created?: string;
    /**
     * ISO 8601 modification timestamp
     */
    modified?: string;
    /**
     * Author of the flashcard deck
     */
    author?: string;
    /**
     * SPDX license identifier (e.g., CC-BY-4.0, MIT, Apache-2.0). See https://spdx.org/licenses/ for valid identifiers. Use 'proprietary' for non-open content
     */
    license?: string;
    tags?: Tags;
    language?: Language;
    difficulty?: number;
    category?: string;
    metadata?: Metadata;
    /**
     * Array of flashcard objects
     */
    cards: Card[];
    /**
     * Dummy property to ensure all definitions are generated
     */
    _generated_keepalive?: {
        id?: Id;
        tags?: Tags1;
        language?: Language;
        metadata?: Metadata;
        direction?: Direction;
        inline?: Inline;
        file?: File;
        url?: Url;
        base64?: Base64;
        mime?: Mime;
        hash?: Hash;
        sort?: Sort;
        card?: Card;
        side?: Side;
        content?: Content2;
        "content-text"?: ContentText;
        "content-markdown"?: ContentMarkdown;
        "content-html"?: ContentHtml;
        "content-latex"?: ContentLatex;
        "content-image"?: ContentImage;
        "content-audio"?: ContentAudio;
        "content-video"?: ContentVideo;
        "content-tts"?: ContentTts;
        "content-mermaid"?: ContentMermaid;
        "content-code"?: ContentCode;
        "content-list"?: ContentList;
        "content-multiple-choice"?: ContentMultipleChoice;
        "content-custom"?: ContentCustom;
        "content-url"?: ContentUrl;
        [k: string]: unknown;
    };

    [k: string]: unknown;
}

/**
 * ISO 639-1 language code
 */
export interface Language {
    [k: string]: unknown;
}

/**
 * Arbitrary key-value metadata
 */
export interface Metadata {
    [k: string]: unknown;
}

/**
 * A single flashcard containing one or more sides with terms and definitions
 */
export interface Card {
    /**
     * Unique identifier for the card
     */
    id: string;
    /**
     * ISO 8601 creation timestamp
     */
    created?: string;
    /**
     * ISO 8601 modification timestamp
     */
    modified?: string;
    tags?: Tags1;
    metadata?: Metadata;
    notes?: Content;
    hint?: Content1;
    /**
     * Array of card sides. Each card can have 1 or more sides to support various patterns (e.g., single-sided cards, term-definition pairs, one term with multiple definitions, etc.)
     *
     * @minItems 1
     */
    sides: [Side, ...Side[]];

    [k: string]: unknown;
}

/**
 * Personal annotations not shown during review
 */
export interface Content {
    [k: string]: unknown;
}

/**
 * Hint shown on request to help answer the card
 */
export interface Content1 {
    [k: string]: unknown;
}

/**
 * A single side of a flashcard containing an array of content items
 */
export interface Side {
    id: Id;
    /**
     * Whether this side is a term or definition. For multi-sided cards, you can have multiple terms or definitions (e.g., term-definition, term-definition-definition, etc.)
     */
    type: "term" | "definition";
    layout?: "vertical" | "horizontal" | "grid" | "custom";
    /**
     * Array of content items (text, images, audio, etc.) that make up this side
     */
    content: Content2[];

    [k: string]: unknown;
}

/**
 * Content item (polymorphic)
 */
export interface Content2 {
    [k: string]: unknown;
}

/**
 * Content hash for cache invalidation and deduplication
 */
export interface Hash {
    algorithm: "sha256" | "sha512" | "sha3-256" | "sha3-512" | "md5";
    value: string;

    [k: string]: unknown;
}

export interface ContentText {
    inline?: Inline;
    file?: File;
    url?: Url;
    base64?: Base64;
    direction?: Direction;
    language?: Language;
    /**
     * Text style variant
     */
    style?: "p" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "subtitle" | "caption";
    /**
     * Name of the Google Font to apply (e.g., 'Roboto', 'Open Sans'). See https://fonts.google.com/
     */
    font?: string;
    /**
     * Indicates if the text contains cloze deletions (e.g. {{answer}})
     */
    cloze?: boolean;

    [k: string]: unknown;
}

export interface ContentMarkdown {
    inline?: Inline;
    file?: File;
    url?: Url;
    base64?: Base64;
    direction?: Direction;
    language?: Language;

    [k: string]: unknown;
}

export interface ContentHtml {
    inline?: Inline;
    file?: File;
    url?: Url;
    base64?: Base64;
    /**
     * Whether to sanitize HTML content
     */
    sanitize?: boolean;
    direction?: Direction;
    language?: Language;

    [k: string]: unknown;
}

export interface ContentLatex {
    inline?: Inline;
    file?: File;
    url?: Url;
    base64?: Base64;
    display?: "inline" | "block";
    direction?: Direction;

    [k: string]: unknown;
}

export interface ContentImage {
    file?: File;
    url?: Url;
    base64?: Base64;
    mime?: Mime;
    hash?: Hash;
    alt?: string;
    caption?: string;
    width?: string;
    height?: string;

    [k: string]: unknown;
}

export interface ContentAudio {
    file?: File;
    url?: Url;
    base64?: Base64;
    mime?: Mime;
    hash?: Hash;
    controls?: boolean;
    autoplay?: boolean;
    /**
     * Subtitle, caption, or description tracks for accessibility
     */
    tracks?: {
        /**
         * Track type: subtitles for translation, captions for deaf/hard-of-hearing, descriptions for audio descriptions
         */
        kind: "subtitles" | "captions" | "descriptions";
        language?: Language;
        /**
         * Human-readable label for track selection UI
         */
        label?: string;
        file?: File;
        url?: Url;
        /**
         * Whether this track should be enabled by default
         */
        default?: boolean;
        [k: string]: unknown;
    }[];

    [k: string]: unknown;
}

export interface ContentVideo {
    /**
     * Video provider to determine which player to use
     */
    provider?: "native" | "youtube" | "vimeo";
    file?: File;
    url?: Url;
    base64?: Base64;
    mime?: Mime;
    hash?: Hash;
    poster?: string;
    controls?: boolean;
    width?: string;
    height?: string;
    /**
     * Start time (e.g., 0s, 1m30s)
     */
    start?: string;
    /**
     * End time
     */
    end?: string;
    autoplay?: boolean;
    language?: Language;
    /**
     * Subtitle, caption, or description tracks for accessibility
     */
    tracks?: {
        /**
         * Track type: subtitles for translation, captions for deaf/hard-of-hearing, descriptions for blind/visually impaired
         */
        kind: "subtitles" | "captions" | "descriptions";
        language?: Language;
        /**
         * Human-readable label for track selection UI
         */
        label?: string;
        file?: File;
        url?: Url;
        /**
         * Whether this track should be enabled by default
         */
        default?: boolean;
        [k: string]: unknown;
    }[];

    [k: string]: unknown;
}

export interface ContentTts {
    /**
     * Text or SSML to synthesize into speech (inline)
     */
    text?: string;
    file?: File;
    url?: Url;
    base64?: Base64;
    /**
     * Voice identifier (implementation-specific)
     */
    voice?: string;
    language?: Language;
    /**
     * Playback speed multiplier
     */
    speed?: number;
    /**
     * Voice pitch adjustment (implementation-specific range)
     */
    pitch?: number;
    /**
     * Volume level (implementation-specific range)
     */
    volume?: number;

    [k: string]: unknown;
}

export interface ContentMermaid {
    inline?: Inline;
    file?: File;
    url?: Url;
    base64?: Base64;
    theme?: string;
    direction?: Direction;

    [k: string]: unknown;
}

export interface ContentCode {
    inline?: Inline;
    file?: File;
    url?: Url;
    base64?: Base64;
    /**
     * Programming language for syntax highlighting (e.g., 'javascript', 'python', 'rust')
     */
    syntax?: string;

    [k: string]: unknown;
}

export interface ContentList {
    /**
     * Array of list items
     *
     * @minItems 1
     */
    items: [Content2, ...Content2[]];
    sort?: Sort;
    /**
     * Custom marker for unordered lists (e.g., 'â€¢', '-', '*'). If not specified, uses default bullet style
     */
    marker?: string;
    /**
     * Starting number for ordered lists
     */
    startNumber?: number;
    direction?: Direction;
    language?: Language;

    [k: string]: unknown;
}

/**
 * Multiple choice question with 2-6 options and one or more correct answers. For questions with multiple correct answers, users must select ALL correct options to be marked as correct (all-or-nothing grading)
 */
export interface ContentMultipleChoice {
    /**
     * Array of answer options
     *
     * @minItems 2
     */
    options: [
        {
            /**
             * ULID identifier (26 characters, Crockford Base32)
             */
            id: string;
            content: Content3;
            description?: Content4;
            hint?: Content5;
            [k: string]: unknown;
        },
        {
            /**
             * ULID identifier (26 characters, Crockford Base32)
             */
            id: string;
            content: Content3;
            description?: Content4;
            hint?: Content5;
            [k: string]: unknown;
        },
        ...{
            /**
             * ULID identifier (26 characters, Crockford Base32)
             */
            id: string;
            content: Content3;
            description?: Content4;
            hint?: Content5;
            [k: string]: unknown;
        }[]
    ];
    /**
     * IDs of correct options. When multiple correct answers are specified, the user MUST select ALL of them to be marked as correct
     *
     * @minItems 1
     */
    correct: [Id, ...Id[]];
    hint?: Content6;
    explanation?: Content7;
    /**
     * Whether to shuffle option order during review
     */
    shuffle?: boolean;
    /**
     * Layout for displaying options
     */
    display?: "vertical" | "horizontal" | "grid";
    level?: Content8;
    /**
     * Point value for scoring
     */
    points?: number;
    direction?: Direction;
    language?: Language;

    [k: string]: unknown;
}

/**
 * Content item (polymorphic)
 */
export interface Content3 {
    [k: string]: unknown;
}

/**
 * Content item (polymorphic)
 */
export interface Content4 {
    [k: string]: unknown;
}

/**
 * Content item (polymorphic)
 */
export interface Content5 {
    [k: string]: unknown;
}

/**
 * Content item (polymorphic)
 */
export interface Content6 {
    [k: string]: unknown;
}

/**
 * Content item (polymorphic)
 */
export interface Content7 {
    [k: string]: unknown;
}

/**
 * Content item (polymorphic)
 */
export interface Content8 {
    [k: string]: unknown;
}

export interface ContentCustom {
    plugin: string;
    config?: {
        [k: string]: unknown;
    };
    inline?: Inline;
    file?: File;
    url?: Url;
    base64?: Base64;
    direction?: Direction;

    [k: string]: unknown;
}

export interface ContentUrl {
    url: Url;
    /**
     * Optional title for the link
     */
    title?: string;
    language?: Language;

    [k: string]: unknown;
}
